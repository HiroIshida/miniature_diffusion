# ─────────────────────────────────────────────────────────────────────────────
# Generated by: ChatGPT (GPT-5 Thinking)
# File: rrt.py
# ─────────────────────────────────────────────────────────────────────────────

import math
import random
from dataclasses import dataclass
from typing import Optional, List, Tuple

import numpy as np


@dataclass
class Node:
    x: float
    y: float
    parent: Optional[int] = None


class RRTConnect2D:
    def __init__(
        self,
        bounds: Tuple[float, float, float, float],
        obstacles: Optional[List[Tuple[float, float, float, float]]] = None,
        step_size: float = 10.0,
        max_iters: int = 10000,
        goal_sample_rate: float = 0.1,
        collision_step: float = 1.0,
        rng=None,
    ):
        self.bounds = tuple(map(float, bounds))
        self.obstacles = obstacles or []
        self.step_size = float(step_size)
        self.max_iters = int(max_iters)
        self.goal_sample_rate = float(goal_sample_rate)
        self.collision_step = float(collision_step)
        self.rng = rng or random.Random()

        # Cached NumPy forms for fast vectorized tests
        self._obs_arr = (
            np.asarray(self.obstacles, dtype=float).reshape(-1, 4)
            if len(self.obstacles) > 0
            else np.empty((0, 4), dtype=float)
        )
        self._bounds_arr = np.asarray(self.bounds, dtype=float)  # [xmin, ymin, xmax, ymax]

    # ---------------------- Public API ----------------------

    def plan(self, start: Tuple[float, float], goal: Tuple[float, float]):
        if not self.point_free(start[0], start[1]) or not self.point_free(goal[0], goal[1]):
            return None

        T_start: List[Node] = [Node(float(start[0]), float(start[1]), None)]
        T_goal: List[Node] = [Node(float(goal[0]), float(goal[1]), None)]

        flip = False
        for _ in range(self.max_iters):
            q_rand = goal if self._rand() < self.goal_sample_rate else self.sample_free()
            if not flip:
                s, ia = self.extend(T_start, q_rand)
                if s != "Trapped":
                    s2, ib = self.connect(T_goal, (T_start[ia].x, T_start[ia].y))
                    if s2 == "Reached":
                        return self.reconstruct(T_start, ia, T_goal, ib)
            else:
                s, ia = self.extend(T_goal, q_rand)
                if s != "Trapped":
                    s2, ib = self.connect(T_start, (T_goal[ia].x, T_goal[ia].y))
                    if s2 == "Reached":
                        return self.reconstruct(T_start, ib, T_goal, ia)
            flip = not flip
        return None

    def shortcut(self, path, iterations: int = 200):
        if not path or len(path) < 3:
            return path
        pts = [tuple(map(float, p)) for p in path]
        for _ in range(int(iterations)):
            if len(pts) == 2:
                return pts
            i = self._randint(0, len(pts) - 3)
            j = self._randint(i + 2, len(pts) - 1)
            if self.segment_free(pts[i][0], pts[i][1], pts[j][0], pts[j][1]):
                pts = pts[: i + 1] + pts[j:]
        return pts

    def sample_free(self) -> Tuple[float, float]:
        xmin, ymin, xmax, ymax = self.bounds
        # Keep the control flow the same (try up to 100); use vectorized check inside point_free
        for _ in range(100):
            x = self._uniform(xmin, xmax)
            y = self._uniform(ymin, ymax)
            if self.point_free(x, y):
                return (x, y)
        # Fallback (unchanged behavior)
        return (self._uniform(xmin, xmax), self._uniform(ymin, ymax))

    def nearest(self, tree: List[Node], q: Tuple[float, float]) -> int:
        # Vectorized squared distances to all nodes
        xs = np.fromiter((n.x for n in tree), dtype=float, count=len(tree))
        ys = np.fromiter((n.y for n in tree), dtype=float, count=len(tree))
        dx = xs - float(q[0])
        dy = ys - float(q[1])
        i = int(np.argmin(dx * dx + dy * dy))
        return i

    def steer(self, from_node: Node, q: Tuple[float, float]) -> Tuple[float, float]:
        dx = q[0] - from_node.x
        dy = q[1] - from_node.y
        d = math.hypot(dx, dy)
        if d <= self.step_size:
            return (float(q[0]), float(q[1]))
        r = self.step_size / d
        return (from_node.x + dx * r, from_node.y + dy * r)

    def extend(self, tree: List[Node], q: Tuple[float, float]):
        i_near = self.nearest(tree, q)
        new_xy = self.steer(tree[i_near], q)
        if self.segment_free(tree[i_near].x, tree[i_near].y, new_xy[0], new_xy[1]):
            tree.append(Node(new_xy[0], new_xy[1], i_near))
            if math.hypot(new_xy[0] - q[0], new_xy[1] - q[1]) <= self.step_size:
                return "Reached", len(tree) - 1
            return "Advanced", len(tree) - 1
        return "Trapped", None

    def connect(self, tree: List[Node], q: Tuple[float, float]):
        status = "Advanced"
        last_idx = None
        while status == "Advanced":
            status, last_idx = self.extend(tree, q)
            if status == "Trapped":
                return "Trapped", last_idx
        return status, last_idx

    def reconstruct(self, tree_start: List[Node], idx_start: int, tree_goal: List[Node], idx_goal: int):
        p1 = self.path_to_root(tree_start, idx_start)
        p2 = self.path_to_root(tree_goal, idx_goal)
        return p1 + p2[::-1][1:]

    def path_to_root(self, tree: List[Node], idx: int):
        out = []
        i = idx
        while i is not None:
            n = tree[i]
            out.append((n.x, n.y))
            i = n.parent
        return out[::-1]

    # ---------------------- Collision & Free-space ----------------------

    def point_free(self, x: float, y: float) -> bool:
        # Scalar wrapper around vectorized _points_free
        return bool(self._points_free(np.asarray([x]), np.asarray([y]))[0])

    def segment_free(self, x0: float, y0: float, x1: float, y1: float) -> bool:
        # Endpoints must be free (unchanged behavior)
        if not self.point_free(x0, y0) or not self.point_free(x1, y1):
            return False

        dx = x1 - x0
        dy = y1 - y0
        L = math.hypot(dx, dy)
        if L == 0.0:
            return self.point_free(x0, y0)

        steps = max(1, int(math.ceil(L / self.collision_step)))

        # Sample along the segment at t = 1/steps, 2/steps, ..., 1.0 (unchanged coverage)
        ts = (np.arange(1, steps + 1, dtype=float) / float(steps))
        xs = x0 + dx * ts
        ys = y0 + dy * ts

        mask = self._points_free(xs, ys)
        return bool(np.all(mask))

    # ---------------------- Helpers (Vectorized) ----------------------

    def _points_free(self, xs: np.ndarray, ys: np.ndarray) -> np.ndarray:
        """
        Vectorized free-space test for arrays of points.
        Returns a boolean array of the same shape as xs/ys indicating whether each point is free.
        """
        xs = np.asarray(xs, dtype=float)
        ys = np.asarray(ys, dtype=float)
        xmin, ymin, xmax, ymax = self._bounds_arr

        in_bounds = (xs >= xmin) & (xs <= xmax) & (ys >= ymin) & (ys <= ymax)

        if self._obs_arr.size == 0:
            return in_bounds

        # Broadcast points against rectangles: each rect is (oxmin, oymin, oxmax, oymax)
        oxmin = self._obs_arr[:, 0][:, None]
        oymin = self._obs_arr[:, 1][:, None]
        oxmax = self._obs_arr[:, 2][:, None]
        oymax = self._obs_arr[:, 3][:, None]

        inside_any_rect = (xs[None, :] >= oxmin) & (xs[None, :] <= oxmax) & (ys[None, :] >= oymin) & (ys[None, :] <= oymax)
        collides = np.any(inside_any_rect, axis=0)

        return in_bounds & (~collides)

    # ---------------------- RNG helpers (compatible with random.Random or numpy Generator) ----------------------

    def _rand(self) -> float:
        # Works for both random.Random and numpy Generator
        return float(self.rng.random())

    def _uniform(self, low: float, high: float) -> float:
        # Works for both random.Random and numpy Generator
        return float(self.rng.uniform(low, high))

    def _randint(self, a: int, b: int) -> int:
        # Inclusive on both ends, matching random.Random.randint
        if hasattr(self.rng, "integers"):  # numpy Generator
            return int(self.rng.integers(a, b + 1))
        return int(self.rng.randint(a, b))
